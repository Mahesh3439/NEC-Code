"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_core_library_1 = require("@microsoft/node-core-library");
const JsonManager_1 = require("./JsonManager");
class ConfigJsonManager extends JsonManager_1.JsonManager {
    constructor(filepath, fs, data, configJsonIsV1) {
        super(filepath, fs, data);
        this.configJsonIsV1 = configJsonIsV1;
    }
    static load(filepath, fs) {
        if (this._instance) {
            throw new Error(`Cannot create a second instance of ConfigJsonManager`);
        }
        let configJson = undefined;
        let configJsonIsV1 = false;
        if (fs.exists(filepath)) {
            try {
                configJson = node_core_library_1.JsonFile.load(filepath);
                configJsonIsV1 = configJson.version === undefined;
            }
            catch (e) {
                throw new Error(`Error reading config.json file: ${e}`);
            }
        }
        ConfigJsonManager._instance = new ConfigJsonManager(filepath, fs, configJson, configJsonIsV1);
    }
    static reset() {
        ConfigJsonManager._instance = undefined;
    }
    static get instance() {
        return this._instance;
    }
    addEntry(bundleEntry, name) {
        if (this.configJsonIsV1) {
            const v1Entry = this._translateV2BundleIntoV1(bundleEntry, name);
            const existingConfig = this._data;
            existingConfig.entries.forEach((existingEntry) => {
                if (existingEntry.manifest === v1Entry.manifest) {
                    throw new Error('You cannot have two config entries for the same manifest.');
                }
            });
            existingConfig.entries.push(v1Entry);
        }
        else {
            const existingConfig = this._data;
            if (existingConfig.bundles[name]) {
                throw new Error('You cannot have two config bundles with the same output name.');
            }
            for (const configBundleName in existingConfig.bundles) { // tslint:disable-line:forin
                const configBundle = existingConfig.bundles[configBundleName];
                for (const component of configBundle.components) {
                    for (const newComponent of bundleEntry.components) {
                        if (component.manifest === newComponent.manifest) {
                            throw new Error('You cannot have two config entries for the same manifest.');
                        }
                    }
                }
            }
            existingConfig.bundles[name] = bundleEntry;
        }
    }
    addLocalizedResource(localizedResourceKey, localizedResourcePath) {
        if (localizedResourceKey && !localizedResourcePath ||
            !localizedResourceKey && localizedResourcePath) {
            throw new Error(`When adding a localized resource, both localized resource key and path must be specified`);
        }
        if (this._data.localizedResources[localizedResourceKey] &&
            this._data.localizedResources[localizedResourceKey] !== localizedResourcePath) {
            throw new Error(`A localized resource with the key "${localizedResourceKey}" already exists in "config.json"`);
        }
        this._data.localizedResources[localizedResourceKey] = localizedResourcePath;
    }
    _translateV2BundleIntoV1(bundle, name) {
        if (bundle.components.length !== 1) {
            throw new Error('New bundle must have exactly one entry');
        }
        return {
            entry: bundle.components[0].entrypoint,
            manifest: bundle.components[0].manifest,
            outputPath: `./dist/${name}.js`
        };
    }
}
exports.ConfigJsonManager = ConfigJsonManager;
//# sourceMappingURL=ConfigJsonManager.js.map