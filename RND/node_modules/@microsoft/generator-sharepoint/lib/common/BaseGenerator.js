"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const path = require("path");
const UpdateNotifier = require("update-notifier");
const yeoman = require("yeoman-generator");
const Utils = require("./utilities");
const PackageJsonManager_1 = require("./PackageJsonManager");
const ConfigJsonManager_1 = require("./ConfigJsonManager");
const ServeJsonManager_1 = require("./ServeJsonManager");
const PackageSolutionJsonManager_1 = require("./PackageSolutionJsonManager");
const YeomanConfiguration_1 = require("./YeomanConfiguration");
class BaseGenerator extends yeoman {
    // tslint:enable:no-any
    constructor(args, options) {
        // Always overwrite the conflict files, without any prompting.
        super(args, (!(options.force = true)) || options);
        this.allowEmptyPackageJson = false;
        this.context = {};
        // Register an error handler for uncaught exceptions:
        this.addListener('error', (errorObject) => {
            let errorMessage = '';
            if (errorObject) {
                if (typeof errorObject === 'string') {
                    errorMessage = errorObject || '';
                }
                else if (errorObject instanceof Error) {
                    errorMessage = errorObject.message || '';
                }
            }
            if (!errorMessage.trim()) {
                errorMessage = 'The operation was unsuccessful';
            }
            console.error('\n' + colors.red('Error: ' + errorMessage));
            process.exitCode = 1;
        });
        // tslint:disable:no-string-literal
        YeomanConfiguration_1.YeomanConfiguration.setStore(this['config']);
        BaseGenerator._checkForUpdates();
        this.option('skip-install', {
            type: Boolean,
            description: 'Skip running package managers (NPM, etc) post scaffolding',
            default: false
        });
    }
    get packageJson() {
        if (!PackageJsonManager_1.PackageJsonManager.instance) {
            PackageJsonManager_1.PackageJsonManager.load(this.destinationPath('package.json'), this.fs);
        }
        if (!this.allowEmptyPackageJson && !PackageJsonManager_1.PackageJsonManager.instance.data) {
            throw new Error(`Cannot find "package.json" file required by this generator`);
        }
        return PackageJsonManager_1.PackageJsonManager.instance;
    }
    get configJson() {
        if (!ConfigJsonManager_1.ConfigJsonManager.instance) {
            ConfigJsonManager_1.ConfigJsonManager.load(this.destinationPath('config/config.json'), this.fs);
        }
        return ConfigJsonManager_1.ConfigJsonManager.instance;
    }
    get serveJson() {
        if (!ServeJsonManager_1.ServeJsonManager.instance) {
            ServeJsonManager_1.ServeJsonManager.load(this.destinationPath('config/serve.json'), this.fs);
        }
        return ServeJsonManager_1.ServeJsonManager.instance;
    }
    get packageSolutionJson() {
        if (!PackageSolutionJsonManager_1.PackageSolutionJsonManager.instance) {
            PackageSolutionJsonManager_1.PackageSolutionJsonManager.load(this.destinationPath('config/package-solution.json'), this.fs);
        }
        return PackageSolutionJsonManager_1.PackageSolutionJsonManager.instance;
    }
    static _checkForUpdates() {
        if (!BaseGenerator._hasCheckedForUpdates) {
            const update = new UpdateNotifier.UpdateNotifier({ pkg: BaseGenerator.generatorPackageJson });
            update.notify({
                defer: false
            }); /* tslint:disable-line:no-any */
        }
        BaseGenerator._hasCheckedForUpdates = true;
    }
    /** Where you write the generator specific files (routes, controllers, etc) */
    writing(shouldCopy = true) {
        // Update config to add the webpart entry.
        this.configJson.save();
        // Update package.json dependencies and trigger npm install if necessary.
        this.packageJson.save();
        // Update serve.json to add the new serve configuration.
        this.serveJson.save();
        // Update package-solution.json to add the new packaging configuration.
        this.packageSolutionJson.save();
        if (shouldCopy) {
            this.copyTemplate(this.sourceRoot(), this.destinationRoot());
        }
    }
    // tslint:disable-next-line:no-any
    tryInstall() {
        const shouldInstall = !this.options['skip-install'];
        if (shouldInstall) {
            switch (YeomanConfiguration_1.YeomanConfiguration.packageManager) {
                case 'yarn':
                    this.yarnInstall();
                    break;
                case 'pnpm':
                    this._doPnpmInstall();
                    break;
                default:
                    this.npmInstall();
                    break;
            }
        }
        return shouldInstall;
    }
    copyTemplate(sourceDirectory, destinationDir) {
        Utils.filesIn(sourceDirectory).map(this._untokenizedCopier(sourceDirectory, destinationDir));
    }
    ensureCorrectFolder() {
        if (this.config.get('whichFolder') === 'subdir') {
            this.destinationRoot(this.destinationPath());
        }
    }
    ensureDependencyGroup(group) {
        const dependencyList = this._getDependencies(group);
        if (!this.packageJson.data.dependencies) {
            this.packageJson.data.dependencies = {};
        }
        if (group === 'webpart' || group === 'extension' || group === 'library') {
            let fileName = 'onPremFirstParty';
            if (YeomanConfiguration_1.YeomanConfiguration.environment !== 'onprem') {
                fileName = YeomanConfiguration_1.YeomanConfiguration.environment === 'onprem19' ? 'onPrem19FirstParty' : 'firstParty';
            }
            fileName = this._getDependencyFileName(fileName);
            const firstPartyDependencies = require(path.join(__dirname, 'dependency', group, fileName));
            const thirdPartyDependencies = require(path.join(__dirname, 'dependency', 'thirdParty.json'));
            this.packageJson.merge(firstPartyDependencies);
            this.packageJson.merge(thirdPartyDependencies);
        }
        Object.keys(dependencyList).forEach(name => {
            this.packageJson.addDependency(name, dependencyList[name]);
        });
        // if at any point we are adding some react typings, then ensure they are in the resolutions for Yarn
        this._addResoutionsIfApplicable(['@types/react']);
    }
    _addResoutionsIfApplicable(packages) {
        if (this.packageJson.data.dependencies) {
            for (const packageName of packages) {
                let packageVersion;
                if (packageVersion = this.packageJson.data.dependencies[packageName]) {
                    this.packageJson.addResolution(packageName, packageVersion);
                }
            }
        }
    }
    _doPnpmInstall() {
        // Awaiting: https://github.com/yeoman/generator/pull/1067
        const installer = 'pnpm';
        const args = ['install'];
        // Follow the same pattern as runInstall(), which uses "once" to ensure only
        // one install for both the solution and the component generators.
        this.env.runLoop.add('install', (done) => {
            this.emit(installer + 'Install');
            this.spawnCommand(installer, args)
                .on('error', (err) => {
                console.log(colors.red('Could not finish installation. \n') +
                    'Please install ' + installer + ' with ' +
                    colors.yellow('npm install -g ' + installer) + ' and try again.');
            })
                .on('exit', (err) => {
                this.emit(installer + 'Install:end');
                done();
            });
        }, { once: installer + ' ' + args.join(' '), run: false });
    }
    _getDependencies(group) {
        return (this._dependencyGroups[group] || {})['dependencies'] || {};
    }
    /* tslint:disable-next-line:no-any */
    get _dependencyGroups() {
        if (!this._dependencyGroupMap) {
            this._dependencyGroupMap = {};
            if (YeomanConfiguration_1.YeomanConfiguration.environment === 'onprem19') {
                this._dependencyGroupMap['react'] = require(path.join(__dirname, 'dependency', 'onPremReact19.json'));
            }
            else if (YeomanConfiguration_1.YeomanConfiguration.environment === 'onprem') {
                this._dependencyGroupMap['react'] = require(path.join(__dirname, 'dependency', 'onPremReact.json'));
            }
            else if (YeomanConfiguration_1.YeomanConfiguration.environment === 'spo') {
                this._dependencyGroupMap['react'] = require(path.join(__dirname, 'dependency', 'react.json'));
            }
            else {
                throw new Error('Environment is not supported');
            }
            this._dependencyGroupMap['knockout'] = require(path.join(__dirname, 'dependency', 'knockout.json'));
            let applicationCustomizerFileName = this._getDependencyFileName('applicationCustomizer');
            let fieldCustomizerFileName = this._getDependencyFileName('fieldCustomizer');
            let commandSetFileName = this._getDependencyFileName('commandSet');
            if (YeomanConfiguration_1.YeomanConfiguration.environment === 'onprem19') {
                applicationCustomizerFileName = 'applicationCustomizerOnPrem19.json';
                fieldCustomizerFileName = 'fieldCustomizerOnPrem19.json';
                commandSetFileName = 'commandSetOnPrem19.json';
            }
            const searchQueryModifierFileName = this._getDependencyFileName('searchQueryModifier');
            this._dependencyGroupMap['applicationCustomizer'] = require(path.join(__dirname, 'dependency', applicationCustomizerFileName)); // tslint:disable-line:max-line-length
            this._dependencyGroupMap['fieldCustomizer'] = require(path.join(__dirname, 'dependency', fieldCustomizerFileName)); // tslint:disable-line:max-line-length
            this._dependencyGroupMap['commandSet'] = require(path.join(__dirname, 'dependency', commandSetFileName));
            this._dependencyGroupMap['searchQueryModifier'] = require(path.join(__dirname, 'dependency', searchQueryModifierFileName)); // tslint:disable-line:max-line-length
        }
        return this._dependencyGroupMap;
    }
    _untokenizedCopier(directory, destination) {
        return (filename) => {
            const sourceFile = path.join(directory, filename);
            const destinationFile = path.join(destination, Utils.untokenize(filename, this.context));
            this.fs.copyTpl(sourceFile, destinationFile, this.context);
        };
    }
    _getDependencyFileName(fileName) {
        if (this.options.plusbeta) {
            fileName += 'PlusBeta';
        }
        fileName += '.json';
        return fileName;
    }
}
/* tslint:disable-next-line:no-any */
BaseGenerator.generatorPackageJson = require('../../package.json');
BaseGenerator._hasCheckedForUpdates = false;
exports.BaseGenerator = BaseGenerator;
//# sourceMappingURL=BaseGenerator.js.map