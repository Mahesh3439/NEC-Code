"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const lodash = require("lodash");
const os = require("os");
const path = require("path");
const Utils = require("../../common/utilities");
const BaseGenerator_1 = require("../../common/BaseGenerator");
const YeomanConfiguration_1 = require("../../common/YeomanConfiguration");
// tslint:disable-next-line:no-any
function composeWith(base, options) {
    Utils.compose(path.basename(__dirname), base, options);
}
exports.composeWith = composeWith;
// tslint:disable-next-line:no-any
function defineOptions(generator) {
    generator.option('solution-name', {
        description: 'Solution name, as well as folder name',
        type: String
    });
    generator.option('framework', {
        description: 'Framework to use. Options are: "none", "react", or "knockout"',
        type: String
    });
    generator.option('environment', {
        description: 'The target environment for the solution. Either "onprem", "onprem19", "spo".',
        type: String
    });
    generator.option('package-manager', {
        description: 'The package manager for the solution. Options are: "npm", "pnpm", or "yarn"',
        type: String
    });
    generator.option('skip-feature-deployment', {
        description: 'If specified, allow the tenant admin the choice of being able to' +
            'deploy the components to all sites immediately without running any ' +
            'feature deployment or adding apps in sites',
        type: Boolean
    });
    generator.option('is-domain-isolated', {
        description: 'If specified, the solution will have permissions to access web APIs ' +
            'that are unique not shared with other components in the tenant',
        type: Boolean
    });
}
exports.defineOptions = defineOptions;
class SolutionGenerator extends BaseGenerator_1.BaseGenerator {
    /* tslint:disable-next-line:no-any */
    constructor(args, options) {
        super(args, options);
        this.allowEmptyPackageJson = true;
        this.friendlyName = 'Solution';
        defineOptions(this);
    }
    initializing() { }
    prompting() {
        if (!this.shouldExecute()) {
            return Promise.resolve();
        }
        return this.prompt([
            {
                type: 'input',
                name: 'solutionName',
                default: lodash.kebabCase(this.appname),
                when: () => !this.config.get('solutionName'),
                message: 'What is your solution name?'
            },
            {
                type: 'list',
                name: 'environment',
                when: () => !this.config.get('environment'),
                message: 'Which baseline packages do you want to target for your component(s)?',
                default: 'spo',
                choices: [
                    { name: 'SharePoint Online only (latest)', value: 'spo' },
                    { name: 'SharePoint 2016 onwards, including 2019 and SharePoint Online', value: 'onprem' },
                    { name: 'SharePoint 2019 onwards, including SharePoint Online', value: 'onprem19' }
                ]
            },
            {
                type: 'list',
                name: 'whichFolder',
                default: 'current',
                when: () => !this.config.get('solutionName'),
                message: 'Where do you want to place the files?',
                choices: [
                    {
                        name: 'Use the current folder',
                        value: 'current'
                    },
                    {
                        name: 'Create a subfolder with solution name',
                        value: 'subdir'
                    }
                ]
            }
        ]).then((answers) => {
            let missingPackageManagerError = '';
            if (!this.config.get('environment')) {
                this.config.set('environment', answers.environment);
            }
            const packageManager = this.config.get('packageManager') || YeomanConfiguration_1.YeomanConfiguration.packageManager || 'npm';
            switch (packageManager) {
                case 'npm':
                    missingPackageManagerError = 'The "npm" tool was not found in your system path.'
                        + os.EOL + 'Please check that it was installed correctly.';
                    break;
                case 'pnpm':
                    missingPackageManagerError = 'The "pnpm" tool was not found in your system path.'
                        + os.EOL + 'If you haven\'t installed it, please visit https://pnpm.js.org for installation instructions.';
                    break;
                case 'yarn':
                    missingPackageManagerError = 'The "yarn" tool was not found in your system path.'
                        + os.EOL + 'If you haven\'t installed it, please visit https://yarnpkg.com/ for installation instructions.';
                    break;
                default:
                    throw new Error(`The package manager specified on the command line must be one of: "npm", "pnpm" or "yarn"`);
            }
            // Before proceeding, make sure the chosen package manager is actually installed
            if (!this.options['skip-install']) {
                try {
                    // We use execSync() instead of spawnSync() because we're capturing the output
                    const foundVersion = child_process.execSync(`${packageManager} -v`, { stdio: ['ignore', 'pipe', 'ignore'] }) // (ignore stderr but not stdout)
                        .toString().trim();
                    // Normally the package managers just print a SemVer pattern and exit
                    if (foundVersion.length < 1 || foundVersion.length > 20) {
                        throw new Error('Unrecognized output from command');
                    }
                    this.log(`Found ${packageManager} version ${foundVersion}`);
                }
                catch (e) {
                    throw new Error(missingPackageManagerError);
                }
            }
            const environment = this.config.get('environment');
            const solutionName = this.config.get('solutionName');
            const skipFeatureDeployment = this.config.get('skipFeatureDeployment');
            const componentType = this.config.get('componentType');
            const extensionType = this.config.get('extensionType');
            const framework = this.config.get('framework');
            const componentName = this.config.get('componentName');
            const componentDescription = this.config.get('componentDescription');
            const isCreatingSolution = this.config.get('isCreatingSolution');
            const isDomainIsolated = this.config.get('isDomainIsolated');
            // Use a sub-dir if they pass solutionName in via option
            this.context.solutionName = this.config.get('solutionName') || answers.solutionName;
            const shouldUseSubDir = answers.whichFolder === 'subdir' || !!this.config.get('solutionName');
            if (shouldUseSubDir) {
                this.config.set('whichFolder', 'subdir');
                // All the sub generators currently point to the config in the root folder
                // so we need to set the values to point at the new .yo-rc file.
                this.destinationRoot(this.destinationPath(this.context.solutionName));
            }
            // Yeoman uses the destinationRoot at the time of instantiation when determining
            // where to write the .yo-rc file, however we want to change the destinationRoot
            // after. Once we change the destinationRoot, the base class instantiates a new
            // storage object. We have a helper class using the storage object, so we need
            // to reset it to use the new object.
            // tslint:disable-next-line:no-string-literal
            YeomanConfiguration_1.YeomanConfiguration.setStore(this['config']);
            this.context.libraryName = lodash.kebabCase(this.context.solutionName);
            this.context.libraryId = Utils.generateGuid();
            // store some variables
            YeomanConfiguration_1.YeomanConfiguration.version = BaseGenerator_1.BaseGenerator.generatorPackageJson.version;
            YeomanConfiguration_1.YeomanConfiguration.libraryName = this.context.libraryName;
            YeomanConfiguration_1.YeomanConfiguration.libraryId = this.context.libraryId;
            YeomanConfiguration_1.YeomanConfiguration.environment = environment;
            YeomanConfiguration_1.YeomanConfiguration.packageManager = packageManager;
            this.config.set('solutionName', solutionName);
            this.config.set('skipFeatureDeployment', skipFeatureDeployment);
            this.config.set('componentType', componentType);
            this.config.set('extensionType', extensionType);
            this.config.set('framework', framework);
            this.config.set('componentName', componentName);
            this.config.set('componentDescription', componentDescription);
            this.config.set('isCreatingSolution', isCreatingSolution);
            this.config.set('isDomainIsolated', isDomainIsolated);
        }).then(() => {
            return this.prompt([
                {
                    type: 'confirm',
                    name: 'skipFeatureDeployment',
                    default: false,
                    when: () => YeomanConfiguration_1.YeomanConfiguration.environment !== 'onprem'
                        && this.config.get('skipFeatureDeployment') === undefined,
                    message: 'Do you want to allow the tenant admin the choice of being able ' +
                        'to deploy the solution to all sites immediately without running ' +
                        'any feature deployment or adding apps in sites?'
                }
            ]);
        }).then((answers) => {
            this.context.skipFeatureDeployment = this.config.get('skipFeatureDeployment') !== undefined ?
                this.config.get('skipFeatureDeployment') : answers.skipFeatureDeployment;
        }).then(() => {
            return this.prompt([
                {
                    type: 'confirm',
                    name: 'isDomainIsolated',
                    default: false,
                    when: () => YeomanConfiguration_1.YeomanConfiguration.environment === 'spo'
                        && this.config.get('isDomainIsolated') === undefined,
                    message: 'Will the components in the solution require permissions to access ' +
                        'web APIs that are unique and not shared with other components in the tenant?'
                }
            ]);
        }).then((answers) => {
            if (YeomanConfiguration_1.YeomanConfiguration.environment === 'spo') {
                if (this.config.get('isDomainIsolated') === undefined) {
                    this.config.set('isDomainIsolated', answers.isDomainIsolated);
                }
                this.context.isDomainIsolated = this.config.get('isDomainIsolated');
            }
            // make sure we store the updated context values
            this.packageSolutionJson.setUpSolution(this.context);
        });
    }
    configuring() {
        if (this.shouldExecute()) {
            const packageJsonTemplate = require('./initial.package.json');
            if (this.packageJson.data) {
                this.log(`Overwriting an existing "package.json"`);
            }
            packageJsonTemplate.name = this.context.libraryName;
            this.packageJson.set(packageJsonTemplate);
            this.ensureDependencyGroup('none');
            if (this.configJson.data) {
                this.log(`Overwriting an existing "config.json"`);
            }
            // SPFx OnPrem requires v1 config files.
            if (YeomanConfiguration_1.YeomanConfiguration.environment === 'onprem') {
                // tslint:disable-next-line:no-any
                this.configJson.set({
                    entries: [],
                    externals: {},
                    localizedResources: {}
                });
                this.configJson.configJsonIsV1 = true;
            }
            else {
                this.configJson.set({
                    '$schema': 'https://developer.microsoft.com/json-schemas/spfx-build/config.2.0.schema.json',
                    version: '2.0',
                    bundles: {},
                    externals: {},
                    localizedResources: {}
                });
            }
        }
    }
    writing() {
        if (this.shouldExecute()) {
            console.log();
            super.writing(false);
            const dest = this.destinationRoot();
            this.copyTemplate(path.join(this.sourceRoot(), YeomanConfiguration_1.YeomanConfiguration.environment), dest);
            this.copyTemplate(path.join(this.sourceRoot(), 'base'), dest);
            this.packageJson.save();
            this.configJson.save();
            this.packageSolutionJson.save();
        }
    }
    install() {
        if (this.shouldExecute()) {
            console.log();
            this.tryInstall();
        }
    }
    end() { }
    shouldExecute() {
        return this.config.get('isCreatingSolution');
    }
}
// Yeoman expects exports of this type, which overrides the TS exports above
// Ensure that anything marked as export above is also listed here
module.exports = SolutionGenerator;
module.exports.composeWith = composeWith;
module.exports.defineOptions = defineOptions;
//# sourceMappingURL=index.js.map